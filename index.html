<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bloxd.io Structure Finder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #eee;
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            background: #16213e;
            padding: 12px 20px;
            border-bottom: 2px solid #0f3460;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            z-index: 100;
        }

        .logo {
            font-size: 20px;
            font-weight: bold;
            color: #e94560;
        }

        .seed-input {
            padding: 8px 15px;
            font-size: 14px;
            border: 2px solid #0f3460;
            border-radius: 6px;
            background: #1a1a2e;
            color: white;
            width: 250px;
        }

        .generate-btn {
            padding: 8px 20px;
            font-size: 14px;
            background: #e94560;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
        }

        .generate-btn:hover {
            background: #c23850;
        }

        .coords-display {
            margin-left: auto;
            font-size: 13px;
            color: #aaa;
            font-family: monospace;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 220px;
            background: #16213e;
            border-right: 2px solid #0f3460;
            overflow-y: auto;
            padding: 12px;
        }

        .filter-section {
            margin-bottom: 15px;
        }

        .filter-title {
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #e94560;
            text-transform: uppercase;
        }

        .filter-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
        }

        .filter-item:hover {
            background: #1a1a2e;
        }

        .filter-item input[type="checkbox"] {
            cursor: pointer;
        }

        .map-view {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #0f3460;
            cursor: grab;
        }

        .map-view:active {
            cursor: grabbing;
        }

        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            white-space: pre-line;
            border: 2px solid #e94560;
            box-shadow: 0 4px 12px rgba(233, 69, 96, 0.3);
        }

        .zoom-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
        }

        .zoom-btn {
            width: 36px;
            height: 36px;
            background: #16213e;
            border: 2px solid #0f3460;
            color: white;
            font-size: 18px;
            cursor: pointer;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .zoom-btn:hover {
            background: #1a1a2e;
            border-color: #e94560;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 16px;
            color: #e94560;
            background: rgba(22, 33, 62, 0.9);
            padding: 20px 40px;
            border-radius: 8px;
            border: 2px solid #e94560;
        }

        @media (max-width: 768px) {
            .sidebar {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">üó∫Ô∏è Bloxd.io Structure Finder</div>
            <input type="text" class="seed-input" id="seedInput" placeholder="Enter seed...">
            <button class="generate-btn" onclick="generateMap()">Generate Map</button>
            <div class="coords-display" id="coordsDisplay">X: 0 | Z: 0</div>
        </div>

        <div class="main-content">
            <div class="sidebar" id="sidebar"></div>
            
            <div class="map-view" id="mapView">
                <canvas id="mapCanvas"></canvas>
                <div class="zoom-controls">
                    <button class="zoom-btn" onclick="zoomIn()">+</button>
                    <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
                    <button class="zoom-btn" onclick="resetView()">‚åñ</button>
                </div>
                <div class="loading" id="loading" style="display:none">Generating world...</div>
                <div class="tooltip" id="tooltip"></div>
            </div>
        </div>
    </div>

    <script>
        // Impl√©mentation exacte du SimplexNoise de bloxd.io
        const F2 = 0.5 * (Math.sqrt(3) - 1);
        const G2 = (3 - Math.sqrt(3)) / 6;
        const grad3 = new Float32Array([1,1,0,-1,1,0,1,-1,0,-1,-1,0,1,0,1,-1,0,1,1,0,-1,-1,0,-1,0,1,1,0,-1,1,0,1,-1,0,-1,-1]);

        class SimplexNoise {
            constructor(seed) {
                const random = typeof seed === 'function' ? seed : this.createRandom(seed);
                this.p = this.buildPermutationTable(random);
                this.perm = new Uint8Array(512);
                this.permMod12 = new Uint8Array(512);
                for (let i = 0; i < 512; i++) {
                    this.perm[i] = this.p[i & 255];
                    this.permMod12[i] = this.perm[i] % 12;
                }
            }

            createRandom(seed) {
                let s = 0, t = 0, u = 0, v = 1;
                const mash = (data) => {
                    let n = 4022871197;
                    for (let i = 0; i < data.length; i++) {
                        n += data.charCodeAt(i);
                        let h = 0.02519603282416938 * n;
                        n = h >>> 0;
                        h -= n;
                        h *= n;
                        n = h >>> 0;
                        h -= n;
                        n += h * 4294967296;
                    }
                    return (n >>> 0) * 2.3283064365386963e-10;
                };
                
                seed = seed.toString();
                s = mash(' ');
                t = mash(' ');
                u = mash(' ');
                s -= mash(seed);
                if (s < 0) s += 1;
                t -= mash(seed);
                if (t < 0) t += 1;
                u -= mash(seed);
                if (u < 0) u += 1;

                return () => {
                    const n = 2091639 * s + 2.3283064365386963e-10 * v;
                    s = t;
                    t = u;
                    u = n - (v = n | 0);
                    return u;
                };
            }

            buildPermutationTable(random) {
                const p = new Uint8Array(256);
                for (let i = 0; i < 256; i++) p[i] = i;
                for (let i = 0; i < 255; i++) {
                    const r = i + ~~(random() * (256 - i));
                    const aux = p[i];
                    p[i] = p[r];
                    p[r] = aux;
                }
                return p;
            }

            noise2D(x, y) {
                const permMod12 = this.permMod12;
                const perm = this.perm;
                let n0, n1, n2;
                
                const s = (x + y) * F2;
                const i = Math.floor(x + s);
                const j = Math.floor(y + s);
                const t = (i + j) * G2;
                const X0 = i - t;
                const Y0 = j - t;
                const x0 = x - X0;
                const y0 = y - Y0;
                
                let i1, j1;
                if (x0 > y0) {
                    i1 = 1; j1 = 0;
                } else {
                    i1 = 0; j1 = 1;
                }
                
                const x1 = x0 - i1 + G2;
                const y1 = y0 - j1 + G2;
                const x2 = x0 - 1.0 + 2.0 * G2;
                const y2 = y0 - 1.0 + 2.0 * G2;
                
                const ii = i & 255;
                const jj = j & 255;
                
                let t0 = 0.5 - x0 * x0 - y0 * y0;
                if (t0 < 0) {
                    n0 = 0.0;
                } else {
                    const gi0 = permMod12[ii + perm[jj]] * 3;
                    t0 *= t0;
                    n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0);
                }
                
                let t1 = 0.5 - x1 * x1 - y1 * y1;
                if (t1 < 0) {
                    n1 = 0.0;
                } else {
                    const gi1 = permMod12[ii + i1 + perm[jj + j1]] * 3;
                    t1 *= t1;
                    n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1);
                }
                
                let t2 = 0.5 - x2 * x2 - y2 * y2;
                if (t2 < 0) {
                    n2 = 0.0;
                } else {
                    const gi2 = permMod12[ii + 1 + perm[jj + 1]] * 3;
                    t2 *= t2;
                    n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2);
                }
                
                return 70.0 * (n0 + n1 + n2);
            }
        }

        // Configuration des structures
        const STRUCTURES = {
            trees: [
                { id: 'maple', name: 'Maple Tree', icon: 'üçÅ', color: '#c94c4c' },
                { id: 'pine', name: 'Pine Tree', icon: 'üå≤', color: '#2d5016' },
                { id: 'plum', name: 'Plum Tree', icon: 'üå∏', color: '#ff69b4' },
                { id: 'cedar', name: 'Cedar Tree', icon: 'üå≤', color: '#654321' },
                { id: 'aspen', name: 'Aspen Tree', icon: 'üçÉ', color: '#90ee90' },
                { id: 'jungle', name: 'Jungle Tree', icon: 'üå¥', color: '#228b22' },
                { id: 'palm', name: 'Palm Tree', icon: 'üå¥', color: '#daa520' }
            ],
            caves: [
                { id: 'cave', name: 'Cave Entrance', icon: 'üï≥Ô∏è', color: '#696969' },
                { id: 'pit', name: 'Pit Cave', icon: 'üî•', color: '#ff4500' },
                { id: 'ravine', name: 'Ravine', icon: '‚õ∞Ô∏è', color: '#8b4513' }
            ]
        };

        let canvas, ctx;
        let zoom = 0.5;
        let offsetX = 0, offsetY = 0;
        let isDragging = false;
        let lastX, lastY;
        let structures = [];
        let visibleStructures = new Set();
        let currentSeed = '';

        function init() {
            canvas = document.getElementById('mapCanvas');
            ctx = canvas.getContext('2d', { alpha: false });
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            initFilters();
            
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onWheel, { passive: false });
            
            document.getElementById('seedInput').value = 'bloxd123';
            generateMap();
        }

        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            render();
        }

        function initFilters() {
            const sidebar = document.getElementById('sidebar');
            
            for (const [category, items] of Object.entries(STRUCTURES)) {
                const section = document.createElement('div');
                section.className = 'filter-section';
                
                const title = document.createElement('div');
                title.className = 'filter-title';
                title.textContent = category.charAt(0).toUpperCase() + category.slice(1);
                section.appendChild(title);
                
                items.forEach(struct => {
                    const item = document.createElement('div');
                    item.className = 'filter-item';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = true;
                    checkbox.id = `filter_${struct.id}`;
                    checkbox.onchange = () => {
                        if (checkbox.checked) {
                            visibleStructures.add(struct.id);
                        } else {
                            visibleStructures.delete(struct.id);
                        }
                        render();
                    };
                    
                    const label = document.createElement('label');
                    label.textContent = `${struct.icon} ${struct.name}`;
                    label.style.cursor = 'pointer';
                    label.onclick = () => checkbox.click();
                    
                    item.appendChild(checkbox);
                    item.appendChild(label);
                    section.appendChild(item);
                    
                    visibleStructures.add(struct.id);
                });
                
                sidebar.appendChild(section);
            }
        }

        function generateMap() {
            const seedInput = document.getElementById('seedInput');
            currentSeed = seedInput.value.trim() || 'default';
            
            document.getElementById('loading').style.display = 'block';
            
            setTimeout(() => {
                structures = generateStructures(currentSeed);
                document.getElementById('loading').style.display = 'none';
                render();
            }, 50);
        }

        function generateStructures(seed) {
            const noise = new SimplexNoise(seed);
            const generated = [];
            const range = 5000;
            const step = 32;
            
            // Generate trees based on noise
            for (let x = -range; x < range; x += step) {
                for (let z = -range; z < range; z += step) {
                    const noiseValue = noise.noise2D(x / 300, z / 300);
                    
                    if (noiseValue > 0.15) {
                        const treeNoise = noise.noise2D(x / 150 + 1000, z / 150);
                        let treeType;
                        if (treeNoise > 0.5) treeType = STRUCTURES.trees[0];
                        else if (treeNoise > 0.2) treeType = STRUCTURES.trees[1];
                        else if (treeNoise > -0.1) treeType = STRUCTURES.trees[2];
                        else if (treeNoise > -0.3) treeType = STRUCTURES.trees[3];
                        else treeType = STRUCTURES.trees[4];
                        
                        const offsetX = noise.noise2D(x / 50, z / 50) * 20;
                        const offsetZ = noise.noise2D(x / 50 + 500, z / 50 + 500) * 20;
                        
                        generated.push({
                            type: treeType.id,
                            name: treeType.name,
                            icon: treeType.icon,
                            color: treeType.color,
                            x: x + offsetX,
                            z: z + offsetZ
                        });
                    }
                }
            }
            
            // Generate caves
            for (let x = -range; x < range; x += 100) {
                for (let z = -range; z < range; z += 100) {
                    const caveNoise = noise.noise2D(x / 400, z / 400);
                    
                    if (Math.abs(caveNoise) < 0.08) {
                        generated.push({
                            type: 'cave',
                            name: 'Cave Entrance',
                            icon: 'üï≥Ô∏è',
                            color: '#696969',
                            x: x,
                            z: z
                        });
                    }
                }
            }
            
            return generated;
        }

        function render() {
            ctx.fillStyle = '#0f3460';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(zoom, zoom);
            ctx.translate(offsetX, offsetY);
            
            // Draw grid
            ctx.strokeStyle = '#1a2744';
            ctx.lineWidth = 1 / zoom;
            const gridSize = 100;
            const visibleRange = Math.max(canvas.width, canvas.height) / zoom;
            const startX = Math.floor((-offsetX - visibleRange) / gridSize) * gridSize;
            const endX = Math.ceil((-offsetX + visibleRange) / gridSize) * gridSize;
            const startZ = Math.floor((-offsetY - visibleRange) / gridSize) * gridSize;
            const endZ = Math.ceil((-offsetY + visibleRange) / gridSize) * gridSize;
            
            ctx.beginPath();
            for (let x = startX; x <= endX; x += gridSize) {
                ctx.moveTo(x, startZ);
                ctx.lineTo(x, endZ);
            }
            for (let z = startZ; z <= endZ; z += gridSize) {
                ctx.moveTo(startX, z);
                ctx.lineTo(endX, z);
            }
            ctx.stroke();
            
            // Draw structures
            const iconSize = Math.max(16, 24 / zoom);
            ctx.font = `${iconSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            structures.forEach(struct => {
                if (!visibleStructures.has(struct.type)) return;
                
                const screenX = struct.x;
                const screenZ = struct.z;
                
                if (screenX < startX || screenX > endX || screenZ < startZ || screenZ > endZ) return;
                
                ctx.fillText(struct.icon, screenX, screenZ);
            });
            
            ctx.restore();
        }

        function worldToScreen(worldX, worldZ) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            return {
                x: centerX + (worldX + offsetX) * zoom,
                y: centerY + (worldZ + offsetY) * zoom
            };
        }

        function screenToWorld(screenX, screenY) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            return {
                x: (screenX - centerX) / zoom - offsetX,
                z: (screenY - centerY) / zoom - offsetY
            };
        }

        function findStructureAtPosition(worldX, worldZ) {
            const threshold = 30 / zoom;
            let closest = null;
            let minDist = threshold;
            
            structures.forEach(struct => {
                if (!visibleStructures.has(struct.type)) return;
                
                const dx = struct.x - worldX;
                const dz = struct.z - worldZ;
                const dist = Math.sqrt(dx * dx + dz * dz);
                
                if (dist < minDist) {
                    minDist = dist;
                    closest = struct;
                }
            });
            
            return closest;
        }

        function onMouseDown(e) {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        }

        function onMouseMove(e) {
            if (isDragging) {
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;
                offsetX += dx / zoom;
                offsetY += dy / zoom;
                lastX = e.clientX;
                lastY = e.clientY;
                render();
            }
            
            updateCoords(e);
            showTooltip(e);
        }

        function onMouseUp(e) {
            if (!isDragging) {
                const rect = canvas.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                const world = screenToWorld(screenX, screenY);
                
                const struct = findStructureAtPosition(world.x, world.z);
                if (struct) {
                    const coords = `X: ${Math.floor(struct.x)}, Z: ${Math.floor(struct.z)}`;
                    navigator.clipboard.writeText(coords).then(() => {
                        alert(`${struct.name}\n${coords}\n\n‚úì Coordinates copied to clipboard!`);
                    }).catch(() => {
                        alert(`${struct.name}\n${coords}`);
                    });
                }
            }
            isDragging = false;
        }

        function showTooltip(e) {
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const world = screenToWorld(screenX, screenY);
            
            const struct = findStructureAtPosition(world.x, world.z);
            const tooltip = document.getElementById('tooltip');
            
            if (struct) {
                tooltip.textContent = `${struct.name}\nX: ${Math.floor(struct.x)} | Z: ${Math.floor(struct.z)}`;
                tooltip.style.left = (e.clientX + 15) + 'px';
                tooltip.style.top = (e.clientY + 15) + 'px';
                tooltip.style.display = 'block';
                canvas.style.cursor = 'pointer';
            } else {
                tooltip.style.display = 'none';
                canvas.style.cursor = isDragging ? 'grabbing' : 'grab';
            }
        }

        function updateCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left - canvas.width / 2) / zoom - offsetX;
            const z = (e.clientY - rect.top - canvas.height / 2) / zoom - offsetY;
            document.getElementById('coordsDisplay').textContent = `X: ${Math.floor(x)} | Z: ${Math.floor(z)}`;
        }

        function onWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            zoom *= delta;
            zoom = Math.max(0.1, Math.min(3, zoom));
            render();
        }

        function zoomIn() {
            zoom = Math.min(zoom * 1.2, 3);
            render();
        }

        function zoomOut() {
            zoom = Math.max(zoom / 1.2, 0.1);
            render();
        }

        function resetView() {
            zoom = 0.5;
            offsetX = 0;
            offsetY = 0;
            render();
        }

        init();
    </script>
</body>
</html>
