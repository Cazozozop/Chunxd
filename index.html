<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G√©n√©rateur de Carte de Structures</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .seed-input-container {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .seed-input {
            padding: 12px 20px;
            font-size: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
            color: white;
            width: 300px;
            transition: all 0.3s;
        }

        .seed-input::placeholder {
            color: rgba(255,255,255,0.7);
        }

        .seed-input:focus {
            outline: none;
            background: rgba(255,255,255,0.2);
            border-color: white;
        }

        .generate-btn {
            padding: 12px 30px;
            font-size: 16px;
            background: white;
            color: #667eea;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
        }

        .map-container {
            position: relative;
            height: 600px;
            background: #8fbc8f;
            overflow: hidden;
            cursor: grab;
            touch-action: none;
            background-image: 
                linear-gradient(rgba(255,255,255,.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,.05) 1px, transparent 1px);
            background-size: 50px 50px;
        }

        .map-container:active {
            cursor: grabbing;
        }

        .map-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: center;
        }

        .structure-marker {
            position: absolute;
            width: 30px;
            height: 30px;
            transform: translate(-50%, -50%);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }

        .structure-marker:hover {
            transform: translate(-50%, -50%) scale(1.4);
            z-index: 100;
        }

        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 12px 18px;
            border-radius: 8px;
            font-size: 13px;
            pointer-events: none;
            z-index: 1000;
            white-space: nowrap;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }

        .controls {
            padding: 20px;
            background: #f8f9fa;
            border-top: 2px solid #e0e0e0;
        }

        .zoom-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .zoom-btn {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s;
        }

        .zoom-btn:hover {
            background: #764ba2;
            transform: scale(1.05);
        }

        .zoom-level {
            padding: 10px 20px;
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-weight: bold;
            color: #667eea;
            min-width: 100px;
            text-align: center;
        }

        .structure-filters {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 12px;
        }

        .filter-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: white;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid #e0e0e0;
        }

        .filter-item:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .filter-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #667eea;
        }

        .filter-item label {
            cursor: pointer;
            font-weight: 500;
            flex: 1;
            font-size: 14px;
        }

        .structure-icon {
            font-size: 18px;
        }

        .stats {
            margin-top: 20px;
            padding: 15px;
            background: white;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
            color: #667eea;
        }

        @media (max-width: 768px) {
            .map-container {
                height: 400px;
            }

            .structure-filters {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 1.8em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üó∫Ô∏è G√©n√©rateur de Carte de Structures</h1>
            <div class="seed-input-container">
                <input type="text" class="seed-input" id="seedInput" placeholder="Entrez une seed (ex: minecraft123)">
                <button class="generate-btn" onclick="generateMap()">G√©n√©rer la Carte</button>
            </div>
        </div>

        <div class="map-container" id="mapContainer">
            <div class="map-canvas" id="mapCanvas"></div>
            <div class="tooltip" id="tooltip"></div>
        </div>

        <div class="controls">
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomOut()">-</button>
                <div class="zoom-level" id="zoomLevel">100%</div>
                <button class="zoom-btn" onclick="zoomIn()">+</button>
                <button class="zoom-btn" onclick="resetView()">üéØ Centrer</button>
            </div>

            <div class="structure-filters" id="structureFilters"></div>

            <div class="stats" id="stats">
                Aucune carte g√©n√©r√©e
            </div>
        </div>
    </div>

    <script>
        // Structures extraites du code source
        const TREE_TYPES = {
            Maple: { id: 0, name: '√ârable', icon: 'üçÅ' },
            Pine: { id: 1, name: 'Pin', icon: 'üå≤' },
            Plum: { id: 2, name: 'Prunier', icon: 'üå∏' },
            Cedar: { id: 4, name: 'C√®dre', icon: 'üå≤' },
            Aspen: { id: 5, name: 'Tremble', icon: 'üçÉ' },
            Jungle: { id: 6, name: 'Jungle', icon: 'üå¥' },
            Palm: { id: 7, name: 'Palmier', icon: 'üå¥' },
            AutumnMaple: { id: 8, name: '√ârable Automne', icon: 'üçÇ' },
            Pear: { id: 9, name: 'Poirier', icon: 'üçê' },
            Cherry: { id: 10, name: 'Cerisier', icon: 'üå∏' },
            Spectral: { id: 11, name: 'Spectral', icon: 'üëª' },
            Mango: { id: 12, name: 'Manguier', icon: 'ü•≠' },
            AutumnAspen: { id: 13, name: 'Tremble Automne', icon: 'üçÇ' }
        };

        const CAVE_TYPES = [
            { id: 'spaghetti', name: 'Caverne Spaghetti', icon: 'üï≥Ô∏è', count: 6 },
            { id: 'pit', name: 'Fosse', icon: 'üî•', count: 2 },
            { id: 'ravine', name: 'Ravin', icon: '‚õ∞Ô∏è', count: 2 },
            { id: 'sphere', name: 'Caverne Sph√©rique', icon: '‚ö™', count: 1 }
        ];

        const STRUCTURE_CONFIGS = [
            ...Object.values(TREE_TYPES).map(tree => ({
                id: `tree_${tree.id}`,
                name: tree.name,
                icon: tree.icon,
                type: 'tree'
            })),
            ...CAVE_TYPES.map(cave => ({
                id: cave.id,
                name: cave.name,
                icon: cave.icon,
                type: 'cave'
            }))
        ];

        let currentSeed = '';
        let structures = [];
        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        let activeFilters = new Set(STRUCTURE_CONFIGS.map(s => s.id));

        // Impl√©mentation du g√©n√©rateur Simplex Noise (simplifi√©)
        class SimplexNoise {
            constructor(seed) {
                this.seed = seed;
                this.p = this.buildPermutationTable(seed);
            }

            buildPermutationTable(seed) {
                const p = [];
                for (let i = 0; i < 256; i++) p[i] = i;
                
                let n, q;
                for (let i = 255; i > 0; i--) {
                    seed = (seed * 9301 + 49297) % 233280;
                    n = seed / 233280;
                    q = Math.floor(n * (i + 1));
                    [p[i], p[q]] = [p[q], p[i]];
                }
                
                return [...p, ...p];
            }

            noise2D(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                
                x -= Math.floor(x);
                y -= Math.floor(y);
                
                const u = this.fade(x);
                const v = this.fade(y);
                
                const A = this.p[X] + Y;
                const B = this.p[X + 1] + Y;
                
                return this.lerp(v,
                    this.lerp(u, this.grad(this.p[A], x, y), this.grad(this.p[B], x - 1, y)),
                    this.lerp(u, this.grad(this.p[A + 1], x, y - 1), this.grad(this.p[B + 1], x - 1, y - 1))
                );
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, y) {
                const h = hash & 3;
                return ((h & 1) === 0 ? x : -x) + ((h & 2) === 0 ? y : -y);
            }
        }

        // G√©n√©rateur pseudo-al√©atoire
        class SeededRandom {
            constructor(seed) {
                this.seed = this.hashString(seed);
            }

            hashString(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return Math.abs(hash);
            }

            next() {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                return this.seed / 233280;
            }

            nextInt(min, max) {
                return Math.floor(this.next() * (max - min + 1)) + min;
            }
        }

        // G√©n√©rateur de points Poisson Disk (inspir√© du code)
        class PoissonDiskGenerator {
            constructor(seed, minDist, width, height) {
                this.rng = new SeededRandom(seed);
                this.minDist = minDist;
                this.width = width;
                this.height = height;
                this.cellSize = minDist / Math.sqrt(2);
                this.grid = [];
                this.active = [];
                this.points = [];
            }

            generate() {
                const cols = Math.ceil(this.width / this.cellSize);
                const rows = Math.ceil(this.height / this.cellSize);
                
                for (let i = 0; i < cols * rows; i++) {
                    this.grid[i] = undefined;
                }

                const x = this.width / 2;
                const y = this.height / 2;
                const pos = [x, y];
                
                const col = Math.floor(x / this.cellSize);
                const row = Math.floor(y / this.cellSize);
                this.grid[col + row * cols] = pos;
                this.active.push(pos);
                this.points.push(pos);

                while (this.active.length > 0) {
                    const randIndex = Math.floor(this.rng.next() * this.active.length);
                    const pos = this.active[randIndex];
                    let found = false;

                    for (let n = 0; n < 30; n++) {
                        const angle = this.rng.next() * Math.PI * 2;
                        const r = this.minDist + this.rng.next() * this.minDist;
                        const newX = pos[0] + Math.cos(angle) * r;
                        const newY = pos[1] + Math.sin(angle) * r;

                        if (newX >= 0 && newX < this.width && newY >= 0 && newY < this.height) {
                            const newCol = Math.floor(newX / this.cellSize);
                            const newRow = Math.floor(newY / this.cellSize);
                            
                            let ok = true;
                            for (let i = -1; i <= 1; i++) {
                                for (let j = -1; j <= 1; j++) {
                                    const index = (newCol + i) + (newRow + j) * cols;
                                    const neighbor = this.grid[index];
                                    if (neighbor) {
                                        const d = Math.hypot(newX - neighbor[0], newY - neighbor[1]);
                                        if (d < this.minDist) {
                                            ok = false;
                                        }
                                    }
                                }
                            }

                            if (ok) {
                                const newPos = [newX, newY];
                                this.grid[newCol + newRow * cols] = newPos;
                                this.active.push(newPos);
                                this.points.push(newPos);
                                found = true;
                                break;
                            }
                        }
                    }

                    if (!found) {
                        this.active.splice(randIndex, 1);
                    }
                }

                return this.points;
            }
        }

        // G√©n√©rer les structures avec l'algorithme du jeu
        function generateStructures(seed) {
            const generated = [];
            const mapSize = 2000;
            const rng = new SeededRandom(seed);
            const noise = new SimplexNoise(seed);

            // G√©n√©rer les arbres avec Poisson Disk
            for (const treeType of Object.values(TREE_TYPES)) {
                const treeSeed = `${seed}_tree_${treeType.id}`;
                const poisson = new PoissonDiskGenerator(treeSeed, 80, mapSize * 2, mapSize * 2);
                const points = poisson.generate();

                points.forEach((point, idx) => {
                    const x = Math.floor(point[0] - mapSize);
                    const z = Math.floor(point[1] - mapSize);
                    
                    // Utiliser le bruit pour varier les biomes
                    const biomeNoise = noise.noise2D(x / 500, z / 500);
                    
                    if (Math.abs(biomeNoise) > 0.3 || idx % 3 !== 0) return; // Filtrer certains arbres

                    generated.push({
                        type: `tree_${treeType.id}`,
                        name: treeType.name,
                        icon: treeType.icon,
                        x: x,
                        z: z,
                        id: `${treeType.name}_${x}_${z}`
                    });
                });
            }

            // G√©n√©rer les cavernes (spaghetti caves)
            const cavePoisson = new PoissonDiskGenerator(`${seed}_caves`, 200, mapSize * 2, mapSize * 2);
            const cavePoints = cavePoisson.generate();

            cavePoints.forEach((point, idx) => {
                const x = Math.floor(point[0] - mapSize);
                const z = Math.floor(point[1] - mapSize);
                
                const caveNoise = noise.noise2D(x / 300, z / 300);
                if (Math.abs(caveNoise) < 0.1) {
                    generated.push({
                        type: 'spaghetti',
                        name: 'Caverne Spaghetti',
                        icon: 'üï≥Ô∏è',
                        x: x,
                        z: z,
                        id: `spaghetti_${x}_${z}`
                    });
                }
            });

            // G√©n√©rer les fosses (moins fr√©quentes)
            for (let i = 0; i < 15; i++) {
                const x = rng.nextInt(-mapSize, mapSize);
                const z = rng.nextInt(-mapSize, mapSize);
                
                generated.push({
                    type: 'pit',
                    name: 'Fosse',
                    icon: 'üî•',
                    x: x,
                    z: z,
                    id: `pit_${x}_${z}`
                });
            }

            // G√©n√©rer les ravins
            for (let i = 0; i < 10; i++) {
                const x = rng.nextInt(-mapSize, mapSize);
                const z = rng.nextInt(-mapSize, mapSize);
                
                generated.push({
                    type: 'ravine',
                    name: 'Ravin',
                    icon: '‚õ∞Ô∏è',
                    x: x,
                    z: z,
                    id: `ravine_${x}_${z}`
                });
            }

            // G√©n√©rer les cavernes sph√©riques
            for (let i = 0; i < 8; i++) {
                const x = rng.nextInt(-mapSize, mapSize);
                const z = rng.nextInt(-mapSize, mapSize);
                
                generated.push({
                    type: 'sphere',
                    name: 'Caverne Sph√©rique',
                    icon: '‚ö™',
                    x: x,
                    z: z,
                    id: `sphere_${x}_${z}`
                });
            }

            return generated;
        }

        // G√©n√©rer la carte
        function generateMap() {
            const seedInput = document.getElementById('seedInput');
            currentSeed = seedInput.value.trim() || 'default_seed';
            
            structures = generateStructures(currentSeed);
            renderMap();
            updateStats();
        }

        // Afficher les structures sur la carte
        function renderMap() {
            const canvas = document.getElementById('mapCanvas');
            canvas.innerHTML = '';

            structures.forEach(struct => {
                if (!activeFilters.has(struct.type)) return;

                const marker = document.createElement('div');
                marker.className = 'structure-marker';
                marker.innerHTML = struct.icon;
                marker.style.left = `${struct.x}px`;
                marker.style.top = `${struct.z}px`;
                marker.dataset.structId = struct.id;

                marker.addEventListener('mouseenter', (e) => showTooltip(e, struct));
                marker.addEventListener('mouseleave', hideTooltip);
                marker.addEventListener('click', () => selectStructure(struct));

                canvas.appendChild(marker);
            });

            updateTransform();
        }

        // Afficher tooltip
        function showTooltip(e, struct) {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                <strong>${struct.name}</strong><br>
                X: ${struct.x}, Z: ${struct.z}
            `;
            tooltip.style.display = 'block';
            updateTooltipPosition(e);
        }

        function updateTooltipPosition(e) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.left = e.pageX + 15 + 'px';
            tooltip.style.top = e.pageY + 15 + 'px';
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }

        // S√©lectionner une structure
        function selectStructure(struct) {
            alert(`${struct.name}\nCoordonn√©es: X=${struct.x}, Z=${struct.z}\nSeed: ${currentSeed}`);
        }

        // Zoom
        function zoomIn() {
            zoom = Math.min(zoom * 1.2, 5);
            updateTransform();
            updateZoomDisplay();
        }

        function zoomOut() {
            zoom = Math.max(zoom / 1.2, 0.1);
            updateTransform();
            updateZoomDisplay();
        }

        function updateZoomDisplay() {
            document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
        }

        function resetView() {
            zoom = 1;
            panX = 0;
            panY = 0;
            updateTransform();
            updateZoomDisplay();
        }

        function updateTransform() {
            const canvas = document.getElementById('mapCanvas');
            canvas.style.transform = `translate(calc(-50% + ${panX}px), calc(-50% + ${panY}px)) scale(${zoom})`;
        }

        // Pan (d√©placement)
        const mapContainer = document.getElementById('mapContainer');
        let touchStartDist = 0;
        let touchStartZoom = 1;

        mapContainer.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        mapContainer.addEventListener('mousemove', (e) => {
            if (isDragging) {
                panX += e.clientX - lastX;
                panY += e.clientY - lastY;
                lastX = e.clientX;
                lastY = e.clientY;
                updateTransform();
            }

            const tooltip = document.getElementById('tooltip');
            if (tooltip.style.display === 'block') {
                updateTooltipPosition(e);
            }
        });

        mapContainer.addEventListener('mouseup', () => {
            isDragging = false;
        });

        mapContainer.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // Scroll pour zoom
        mapContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.deltaY < 0) {
                zoomIn();
            } else {
                zoomOut();
            }
        });

        // Touch events pour mobile
        mapContainer.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchStartDist = Math.sqrt(dx * dx + dy * dy);
                touchStartZoom = zoom;
            } else if (e.touches.length === 1) {
                isDragging = true;
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
            }
        });

        mapContainer.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                zoom = touchStartZoom * (dist / touchStartDist);
                zoom = Math.max(0.1, Math.min(5, zoom));
                updateTransform();
                updateZoomDisplay();
            } else if (e.touches.length === 1 && isDragging) {
                panX += e.touches[0].clientX - lastX;
                panY += e.touches[0].clientY - lastY;
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
                updateTransform();
            }
        });

        mapContainer.addEventListener('touchend', () => {
            isDragging = false;
        });

        // Cr√©er les filtres
        function initFilters() {
            const container = document.getElementById('structureFilters');
            
            STRUCTURE_CONFIGS.forEach(struct => {
                const item = document.createElement('div');
                item.className = 'filter-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `filter_${struct.id}`;
                checkbox.checked = true;
                checkbox.addEventListener('change', () => toggleFilter(struct.id));
                
                const icon = document.createElement('span');
                icon.className = 'structure-icon';
                icon.textContent = struct.icon;
                
                const label = document.createElement('label');
                label.htmlFor = `filter_${struct.id}`;
                label.textContent = struct.name;
                
                item.appendChild(checkbox);
                item.appendChild(icon);
                item.appendChild(label);
                
                item.addEventListener('click', (e) => {
                    if (e.target !== checkbox) {
                        checkbox.checked = !checkbox.checked;
                        toggleFilter(struct.id);
                    }
                });
                
                container.appendChild(item);
            });
        }

        function toggleFilter(structId) {
            if (activeFilters.has(structId)) {
                activeFilters.delete(structId);
            } else {
                activeFilters.add(structId);
            }
            renderMap();
            updateStats();
        }

        function updateStats() {
            const visible = structures.filter(s => activeFilters.has(s.type)).length;
            const total = structures.length;
            document.getElementById('stats').textContent = 
                `Seed: "${currentSeed}" | ${visible} structures visibles sur ${total} | Zoom: ${Math.round(zoom * 100)}%`;
        }

        // Initialisation
        initFilters();
        
        // G√©n√©rer une carte par d√©faut
        document.getElementById('seedInput').value = 'minecraft123';
        generateMap();
    </script>
</body>
</html>
